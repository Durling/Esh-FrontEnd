'use strict';

var path = require('path');
var src = process.cwd();



module.exports = function(grunt, opt) {
	var options = opt || {};

	//var include = opt.include || [/.*/];
	var _ = grunt.util._;

	var ignoreReg = opt.ignore || opt.excludeList || [/\.js(\?.*)?$/, /\.css(\?.*)?$/, /\.svg(\?.*)?$/, /\.ico(\?.*)?$/,
		/\.woff(\?.*)?$/, /\.png(\?.*)?$/, /\.jpg(\?.*)?$/, /\.jpeg(\?.*)?$/, /\.gif(\?.*)?$/, /\.pdf(\?.*)?$/
	];

	var includeReg = opt.include || [/.*/];

	function accept(req) {
		var ha = req.headers["accept"];
		if (!ha) return false;
		return (~ha.indexOf("html"));
	}

	function check(str, arr) {
		if (!str) return true;
		return arr.some(function(item) {
			if ((item.test && item.test(str)) || ~str.indexOf(item)) return true;
			return false;
		});
	}


	// Variables available in ALL files
	var globalVars = options.globals;

	// Names of our variables
	var globalVarNames = Object.keys(globalVars);

	globalVarNames.forEach(function(globalVarName) {
		if (_.isString(globalVars[globalVarName])) {
			globalVars[globalVarName] = globalVars[globalVarName];
		} else {
			globalVars[globalVarName] = JSON.stringify(globalVars[globalVarName]);
		}
	});

	// Cached variable regular expressions
	var globalVarRegExps = {};

	function replace(contents, localVars) {

		localVars = localVars || {};

		var varNames = Object.keys(localVars);
		var varRegExps = {};

		// Replace local vars
		varNames.forEach(function(varName) {

			// Process lo-dash templates (for strings) in global variables and JSON.stringify the rest
			if (_.isString(localVars[varName])) {
				localVars[varName] = grunt.template.process(localVars[varName]);
			} else {
				localVars[varName] = JSON.stringify(localVars[varName]);
			}

			varRegExps[varName] = varRegExps[varName] || new RegExp(options.prefix + varName + options.suffix, 'g');

			contents = contents.replace(varRegExps[varName], localVars[varName]);
		});

		// Replace global variables
		globalVarNames.forEach(function(globalVarName) {

			globalVarRegExps[globalVarName] = globalVarRegExps[globalVarName] || new RegExp(options.prefix + globalVarName + options.suffix, 'g');

			contents = contents.replace(globalVarRegExps[globalVarName], globalVars[globalVarName]);
		});

		return contents;
	}

	var includeRegExp = new RegExp(options.prefix + 'include\\(\\s*["\'](.*?)["\'](,\\s*({[\\s\\S]*?})){0,1}\\s*\\)' + options.suffix);

	function include(contents, workingDir) {

		var matches = includeRegExp.exec(contents);

		// Create a function that can be passed to String.replace as the second arg
		function createReplaceFn(replacement) {
			return function() {
				return replacement;
			};
		}

		function getIncludeContents(includePath, localVars) {
			var files = grunt.file.expand(includePath),
				includeContents = '';

			// If files is not an array of at least one element then bad
			if (!files.length) {
				grunt.log.warn('Include file(s) not found', includePath);
			}

			files.forEach(function(filePath, index) {
				includeContents += grunt.file.read(filePath);
				// break a line for every file, except for the last one
				includeContents += index !== files.length - 1 ? '\n' : '';

				// Make replacements
				includeContents = replace(includeContents, localVars);

				// Process includes
				includeContents = include(includeContents, path.dirname(filePath));
				if (options.processIncludeContents && typeof options.processIncludeContents === 'function') {
					includeContents = options.processIncludeContents(includeContents, localVars, filePath);
				}
			});

			return includeContents;
		}

		while (matches) {

			var match = matches[0];
			var includePath = matches[1];
			var localVars = matches[3] ? JSON.parse(matches[3]) : {};

			if (!grunt.file.isPathAbsolute(includePath)) {
				includePath = path.resolve(path.join((options.includesDir ? options.includesDir : workingDir), includePath));
			} else {
				if (options.includesDir) {
					grunt.log.error('includesDir works only with relative paths. Could not apply includesDir to ' + includePath);
				}
				includePath = path.resolve(includePath);
			}

			var docroot = path.relative(path.dirname(includePath), path.resolve(options.docroot)).replace(/\\/g, '/');

			// Set docroot as local var but don't overwrite if the user has specified
			if (localVars.docroot === undefined) {
				localVars.docroot = docroot ? docroot + '/' : '';
			}

			if (grunt.file.exists(includePath)) {
				grunt.log.debug('Including', includePath);
			}

			grunt.log.debug('Locals', localVars);

			var includeContents = getIncludeContents(includePath, localVars);
			contents = contents.replace(match, createReplaceFn(includeContents));

			matches = includeRegExp.exec(contents);
		}

		return contents;
	}


	return function livereload(req, res, next) {
		if (res._inlivereload) return next();
		res._inlivereload = true;
		if (!accept(req) || !check(req.url, includeReg) || check(req.url, ignoreReg)) {
			return next();
		}

		var runPatches = true;
		var writeHead = res.writeHead;
		var write = res.write;
		var end = res.end;

		res.pushData = function(chunk) {
			res._data = (res._data || '') + chunk;
		};

		res.inject = res.write = function(string, encoding) {
			if (!runPatches) return write.call(res, string, encoding);

			if (string !== undefined) {
				var body = string instanceof Buffer ? string.toString(encoding) : string;

				var docroot = path.relative(path.dirname(src), path.resolve(options.docroot)).replace(/\\/g, '/');
				var localVars = {
					docroot: docroot ? docroot + '/' : ''
				};
				body = replace(body, localVars);
				body = include(body, path.dirname(src));
				res.pushData(body);
				return true;

			}
			return true;
		};

		res.writeHead = function() {
			if (!runPatches) return writeHead.apply(res, arguments);

			var headers = arguments[arguments.length - 1];
			if (typeof headers === 'object') {
				for (var name in headers) {
					if (/content-length/i.test(name)) {
						delete headers[name];
					}
				}
			}

			if (res.getHeader('content-length')) res.removeHeader('content-length');

			writeHead.apply(res, arguments);
		};

		res.end = function(string, encoding) {
			if (!runPatches) return end.call(res, string, encoding);

			res.inject(string);
			runPatches = false;
			if (res._data !== undefined && !res._header) res.setHeader('content-length', Buffer.byteLength(res._data, encoding));
			end.call(res, res._data, encoding);
		};

		next();
	};

};